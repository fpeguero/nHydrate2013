//------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated from a template.
//
//    Manual changes to this file may cause unexpected behavior in your application.
//    Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable 0168
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Xml;
using System.Security.Cryptography;
using System.IO;
using System.Windows.Forms;

namespace PROJECTNAMESPACE
{
	/// <summary>
	/// Provides installation functionality for databases
	/// </summary>
	internal class UpgradeInstaller
	{
		#region member variables

		internal static readonly GeneratedVersion _def_Version = new GeneratedVersion(-1, -1, -1, -1, -1);

		internal const string DEFAULT_NAMESPACE = "PROJECTNAMESPACE";
		internal const string MODELKEY = "%MODELKEY%";
		private GeneratedVersion _previousVersion = null;
		private static GeneratedVersion _upgradeToVersion = new GeneratedVersion("UPGRADE_VERSION");
		private InstallSetup _setup = null;
		private System.Data.SqlClient.SqlConnection _connection;
		private System.Data.SqlClient.SqlTransaction _transaction;
		private List<EmbeddedResourceName> _resourceNames = new List<EmbeddedResourceName>();
		private List<nHydrateDbObject> _databaseItems = new List<nHydrateDbObject>();

		private const string UPGRADE_GENERATED_FOLDER = "._2_Upgrade_Scripts.";

		#endregion

		private static GeneratedVersion UpgradeToVersion
		{
			get { return UpgradeInstaller._upgradeToVersion; }
		}

		/// <summary>
		/// Upgrades a database to the newest schema
		/// </summary>
		public static void UpgradeDatabase(InstallSetup setup)
		{
			#region Verify that the database can be opened

			//Try this 10 times and then fail
			var isError = true;
			while (isError)
			{
				try
				{
					var settings = new nHydrateSetting();
					settings.Load(setup.ConnectionString);
					isError = false;
				}
				catch (Exception ex)
				{
					System.Threading.Thread.Sleep(500);
					isError = true;
				}
			}

			#endregion

			try
			{
				var upgradeInstaller = new UpgradeInstaller(setup);
				upgradeInstaller.Initialize();
				upgradeInstaller.RunUpgrade(setup);
			}
			catch (Exception ex)
			{
				throw;
			}
		}

		public static void AzureCopyDatabase(InstallSettings settings)
		{
			var o = new AzureCopy();
			o.Run(settings);
		}

		#region construct / initialize

		private UpgradeInstaller(InstallSetup setup)
		{
			if (setup == null)
				throw new Exception("The setup object cannot be null.");

			if (setup.Version == null)
				_previousVersion = new GeneratedVersion(_def_Version);
			else
				_previousVersion = setup.Version;
			_setup = setup;
		}

		private void Initialize()
		{
			var settings = new nHydrateSetting();
			if (_setup.Version == null)
			{
				settings.Load(_setup.ConnectionString);
			}
			else
			{
				settings.dbVersion = _setup.Version.ToString();
				settings.ModelKey = new Guid(MODELKEY);
			}

			//Verify that this is the proper database for this model, if there is a previous key
			if (settings.ModelKey != Guid.Empty)
			{
				if (settings.ModelKey != new Guid(MODELKEY))
				{
					if (System.Windows.Forms.MessageBox.Show("The database being updated was created against a different model. This may cause database versioning issues if you continue.\n\nDo you wish to continue?", "Continue?", System.Windows.Forms.MessageBoxButtons.YesNo, System.Windows.Forms.MessageBoxIcon.Warning) != System.Windows.Forms.DialogResult.Yes)
					{
						throw new Exception("Database does not match model.");
					}
				}
			}

			if (settings.dbVersion != string.Empty)
			{
				string[] versionNumbers = settings.dbVersion.Split('.');
				_previousVersion = new GeneratedVersion();
				_previousVersion.Major = int.Parse(versionNumbers[0]);
				_previousVersion.Minor = int.Parse(versionNumbers[1]);
				_previousVersion.Revision = int.Parse(versionNumbers[2]);
				_previousVersion.Build = int.Parse(versionNumbers[3]);
				if (versionNumbers.Length >= 5)
					_previousVersion.Generated = int.Parse(versionNumbers[4]);
			}
			var assem = Assembly.GetExecutingAssembly();
			var resourceNames = assem.GetManifestResourceNames();
			foreach (string resourceName in resourceNames)
			{
				var ern = new EmbeddedResourceName(resourceName);
				_resourceNames.Add(ern);
			}
		}

		#endregion

		public static string GetScript(InstallSetup setup)
		{
			var tempss = new List<string>();
			if (setup.InstallStatus == InstallStatusConstants.Create)
			{
				tempss.AddRange(setup.SkipSections);
				setup.SkipSections.Add("FIELD CREATE");
				setup.SkipSections.Add("AUDIT TRAIL CREATE");
				setup.SkipSections.Add("AUDIT TRAIL REMOVE");
				setup.SkipSections.Add("RENAME PK");
				setup.SkipSections.Add("DROP PK");
				setup.SkipSections.Add("REMOVE DEFAULTS");
				setup.SkipSections.Add("CREATE DEFAULTS");
			}

			var upgradeInstaller = new UpgradeInstaller(setup);
			upgradeInstaller.Initialize();
			if (setup.InstallStatus == InstallStatusConstants.Upgrade)
				upgradeInstaller._databaseItems = nHydrateDbObject.Load(setup.ConnectionString, MODELKEY, null);
			var sb = new StringBuilder();
			upgradeInstaller.UpgradeFolder1(sb, setup);
			upgradeInstaller.UpgradeFolder2(sb, setup);
			upgradeInstaller.UpgradeFolder3(sb, setup);
			upgradeInstaller.UpgradeFolder4(sb, setup);
			upgradeInstaller.UpgradeFolder5(sb, setup);
			upgradeInstaller.UpgradeFolder6(sb, setup);

			var settings = new nHydrateSetting();
			settings.dbVersion = UpgradeInstaller.UpgradeToVersion.ToString(".");
			settings.LastUpdate = DateTime.Now;
			settings.ModelKey = new Guid(MODELKEY);
			settings.History.Add(new HistoryItem()
			{
				Version = UpgradeInstaller.UpgradeToVersion.ToString("."),
				PublishDate = DateTime.Now
			});
			sb.AppendLine(settings.GetVersionUpdateScript());
			sb.AppendLine("GO");

			//Create the table if need be
			sb.AppendLine("if not exists(select * from sys.objects where name = '__nhydrateobjects'and type = 'U')" + Environment.NewLine +
																					 "CREATE TABLE [dbo].[__nhydrateobjects]" +
																					 "([rowid] [bigint] IDENTITY(1,1) NOT NULL," +
																					 "[id] [uniqueidentifier] NULL," +
																					 "[name] [varchar](500) NOT NULL," +
																					 "[type] [varchar](10) NOT NULL," +
																					 "[schema] [varchar](500) NULL," +
																					 "[CreatedDate] [datetime] NOT NULL," +
																					 "[ModifiedDate] [datetime] NOT NULL," +
																					 "[Hash] [varchar](32) NULL," +
																					 "[Status] [varchar](500) NULL," +
																					 "[ModelKey] [uniqueidentifier] NOT NULL)");
			sb.AppendLine("GO");
			sb.AppendLine("if exists(select * from sys.objects where name = '__nhydrateobjects' and type = 'U') AND not exists (select * from syscolumns c inner join sysobjects o on c.id = o.id where c.name = 'status' and o.name = '__nhydrateobjects')");
			sb.AppendLine("ALTER TABLE [dbo].[__nhydrateobjects] ADD [status] [Varchar] (500) NULL");
			sb.AppendLine("GO");
			sb.AppendLine("delete from [__nhydrateobjects] where [id] IS NULL and ModelKey = '" + UpgradeInstaller.MODELKEY + "'");
			sb.AppendLine("GO");

			//Add DB objects
			sb.AppendLine();
			foreach (var item in upgradeInstaller._databaseItems.Where(x => x.Changed))
			{
				var sql = "if exists(select * from [__nhydrateobjects] where [id] = '" + item.id + "') " +
																		 "update [__nhydrateobjects] set [name] = '" + item.name + "', [type] = '" + item.type + "', [schema] = '" + item.schema + "', [CreatedDate] = '" + item.CreatedDate.ToString("yyyy-MM-dd HH:mm:ss") + "', [ModifiedDate] = '" + item.ModifiedDate.ToString("yyyy-MM-dd HH:mm:ss") + "', [Hash] = '" + item.Hash + "', [ModelKey] = '" + item.ModelKey + "', [Status] = '" + item.Status + "' where [id] = '" + item.id + "' " +
																		 "else " +
																		 "insert into [__nhydrateobjects] ([id], [name], [type], [schema], [CreatedDate], [ModifiedDate], [Hash], [ModelKey], [Status]) values ('" + item.id + "', '" + item.name + "', '" + item.type + "', '" + item.schema + "', '" + item.CreatedDate.ToString("yyyy-MM-dd HH:mm:ss") + "', '" + item.ModifiedDate.ToString("yyyy-MM-dd HH:mm:ss") + "', '" + item.Hash + "', '" + item.ModelKey + "', '" + item.Status + "')";
				sb.AppendLine(sql);
			}
			sb.AppendLine("GO");
			sb.AppendLine();

			try
			{
				var s = sb.ToString().Replace("--DO NOT MODIFY THIS FILE. IT IS ALWAYS OVERWRITTEN ON GENERATION.\r\n", string.Empty);
				while (s.StartsWith("\r\n"))
				{
					s = s.Substring(2);
				}
				while (s.StartsWith("GO\r\n"))
				{
					s = s.Substring(4);
				}
				return s;
			}
			catch (Exception ex)
			{
				return sb.ToString();
			}
			finally
			{
				if (setup.InstallStatus == InstallStatusConstants.Create)
				{
					setup.SkipSections.Clear();
					setup.SkipSections.AddRange(tempss);
				}
			}
		}

		public static bool NeedsUpdate(string connectionString)
		{
			var settings = new nHydrateSetting();
			settings.Load(connectionString);
			if (!settings.IsLoaded) return true; //Cannot find version so upgrade

			var currentDbVersion = _def_Version;
			if (!string.IsNullOrEmpty(settings.dbVersion))
				currentDbVersion = new GeneratedVersion(settings.dbVersion.Split('.'));
			else
				return true;

			return (currentDbVersion < UpgradeInstaller.UpgradeToVersion);
		}

		public static string VersionInstalled(string connectionString)
		{
			var settings = new nHydrateSetting();
			settings.Load(connectionString);
			var currentDbVersion = _def_Version;
			if (settings.IsLoaded)
			{
				if (!string.IsNullOrEmpty(settings.dbVersion))
					currentDbVersion = new GeneratedVersion(settings.dbVersion.Split('.'));
			}
			return currentDbVersion.ToString();
		}

		public static string VersionLatest()
		{
			return _upgradeToVersion.ToString();
		}

		public static bool IsVersioned(string connectionString)
		{
			var settings = new nHydrateSetting();
			settings.Load(connectionString);
			var currentDbVersion = _def_Version;
			if (settings.IsLoaded)
			{
				if (!string.IsNullOrEmpty(settings.dbVersion))
					currentDbVersion = new GeneratedVersion(settings.dbVersion.Split('.'));
			}
			return (currentDbVersion != _def_Version);
		}

		private void RunUpgrade(InstallSetup setup)
		{
			if (setup.Transaction == null || !setup.UseTransaction)
			{
				_connection = new System.Data.SqlClient.SqlConnection(setup.ConnectionString);
				_connection.Open();
				if (setup.UseTransaction)
					_transaction = _connection.BeginTransaction(System.Data.IsolationLevel.RepeatableRead);
			}
			else //transaction is NOT null AND UseTransaction is TRUE
			{
				_connection = setup.Transaction.Connection;
				_transaction = setup.Transaction;
			}

			//If this is a create then skip some unnecessary script sections
			if (setup.InstallStatus == InstallStatusConstants.Create && setup.SkipSections == null)
			{
				var skipSections = new List<string>();
				skipSections.Add("FIELD CREATE");
				skipSections.Add("AUDIT TRAIL REMOVE");
				skipSections.Add("RENAME PK");
				skipSections.Add("DROP PK");
				skipSections.Add("REMOVE DEFAULTS");
				setup.SkipSections = skipSections;
			}

			_databaseItems = nHydrateDbObject.Load(setup.ConnectionString, MODELKEY, _transaction);
			var timer = new System.Diagnostics.Stopwatch();

			try
			{
				var settings = new nHydrateSetting();
				settings.Load(setup.ConnectionString);

				var currentDbVersion = _def_Version;
				if (!string.IsNullOrEmpty(settings.dbVersion))
					currentDbVersion = new GeneratedVersion(settings.dbVersion.Split('.'));

				if (currentDbVersion > _upgradeToVersion)
				{
					System.Windows.Forms.MessageBox.Show("The current database version (" + currentDbVersion.ToString() + ") is greater than the current library (" + _upgradeToVersion.ToString() + "). The upgrade will not proceed.", "Error", System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Error);
					return;
				}

				#region Verify Upgrade Scripts

				if (settings.WasLegacy) setup.AcceptVersionWarnings = true; //Do not show prompts for old scripts, since there is no way to verify
				if (setup.InstallStatus == InstallStatusConstants.Upgrade)
				{
					//Test Upgrades for missed scripts
					var upgradeSchemaScripts = this.GetResourceNameUnderLocation(UPGRADE_GENERATED_FOLDER);
					var sortByVersionScripts = new SortedDictionary<string, EmbeddedResourceName>(upgradeSchemaScripts, new UpgradeFileNameComparer());
					foreach (var item in sortByVersionScripts)
					{
						var hashValue = string.Join("\r\nGO\r\n", SqlServers.ReadSQLFileSectionsFromResource(item.Key, setup)).CalculateMD5Hash();
						var fileName = item.Key.Substring(item.Key.IndexOf(UPGRADE_GENERATED_FOLDER) + UPGRADE_GENERATED_FOLDER.Length, item.Key.Length - (item.Key.IndexOf(UPGRADE_GENERATED_FOLDER) + UPGRADE_GENERATED_FOLDER.Length));
						var di = _databaseItems.FirstOrDefault(x => x.name == item.Key);
						if (di == null)
						{
							var fileVersion = new GeneratedVersion(fileName);
							if ((new GeneratedVersion(settings.dbVersion.Split('.'))) > fileVersion)
							{
								//script is in installer but never run on database
								if (!setup.AcceptVersionWarnings)
								{
									if (MessageBox.Show("The script '" + fileName + "' is part of the install but has never been applied to the database. The script version is lower than the database version so it will never be applied. Do you wish to proceed with the install?", "Script never applied", MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.No)
										throw new ScriptDifferenceException("The script '" + fileName + "' has never been applied to the database and never will due to its version.");
								}

								_databaseItems.Add(new nHydrateDbObject()
								{
									name = item.Key,
									type = "FILE",
									Hash = hashValue,
									ModelKey = new Guid(MODELKEY),
									Status = "skipped:upgrade",
									Changed = true,
								});

								UpgradeInstaller.LogInfo("The script '" + fileName + "' has never been applied to the database and never will due to its version.");
							}
						}
						else if (di.Hash != hashValue)
						{
							//Said script is in installer and was run but the installer version is different than what was run
							if (!setup.AcceptVersionWarnings)
							{
								if (MessageBox.Show("The script '" + fileName + "' was previously run on the database, but the current script is not the same. Do you wish to proceed with the install?", "Script has changed", MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.No)
									throw new ScriptDifferenceException("The script '" + fileName + "' is different than the one run on the database.");
							}

							di.Hash = hashValue;
							di.Status = "versiondiff:upgrade";
							di.Changed = true;
							UpgradeInstaller.LogInfo("The script '" + fileName + "' is different than the one run on the database.");
						}
					}
				}
				else if (setup.InstallStatus == InstallStatusConstants.Create)
				{
					//Test Upgrades for missed scripts
					var upgradeSchemaScripts = this.GetResourceNameUnderLocation(UPGRADE_GENERATED_FOLDER);
					var sortByVersionScripts = new SortedDictionary<string, EmbeddedResourceName>(upgradeSchemaScripts, new UpgradeFileNameComparer());
					foreach (var item in sortByVersionScripts)
					{
						var hashValue = string.Join("\r\nGO\r\n", SqlServers.ReadSQLFileSectionsFromResource(item.Key, setup)).CalculateMD5Hash();
						var fileName = item.Key.Substring(item.Key.IndexOf(UPGRADE_GENERATED_FOLDER) + UPGRADE_GENERATED_FOLDER.Length, item.Key.Length - (item.Key.IndexOf(UPGRADE_GENERATED_FOLDER) + UPGRADE_GENERATED_FOLDER.Length));
						var fileVersion = new GeneratedVersion(fileName);
						_databaseItems.Add(new nHydrateDbObject()
						{
							name = item.Key,
							type = "FILE",
							Hash = hashValue,
							ModelKey = new Guid(MODELKEY),
							Status = "skipped:create",
							Changed = true,
						});

						UpgradeInstaller.LogError(null, "The script '" + fileName + "' has never been applied to the database and never will due to its version.");
					}
				}

				#endregion

				timer.Stop();
				timer.Reset();
				timer.Start();

				#region 1_UserDefinedInitialization

				this.UpgradeFolder1(setup);

				#endregion

				#region 2_Upgrade Scripts

				this.UpgradeFolder2(setup);

				#endregion

				#region 3_GeneratedTablesAndData

				this.UpgradeFolder3(setup);

				#endregion

				#region 4_UserDefinedPostTablesAndData

				this.UpgradeFolder4(setup);

				#endregion

				#region 5_Programmability

				UpgradeFolder5(setup);

				#endregion

				#region 6_UserDefinedFinalize

				UpgradeFolder6(setup);

				#endregion

				nHydrateDbObject.Save(setup.ConnectionString, MODELKEY, _databaseItems, _transaction);

				//Do not commit if external transaction
				if (_transaction != null)
					_transaction.Commit();

				settings.dbVersion = _upgradeToVersion.ToString(".");
				settings.LastUpdate = DateTime.Now;
				settings.ModelKey = new Guid(MODELKEY);
				if (!settings.History.Any(x => x.Version == _upgradeToVersion.ToString(".")))
				{
					settings.History.Add(new HistoryItem()
					{
						Version = _upgradeToVersion.ToString("."),
						PublishDate = DateTime.Now
					});
				}
				settings.Save(setup.ConnectionString);

				SqlServers.DeleteExtendedProperty(setup.ConnectionString, "dbVersion");
				SqlServers.DeleteExtendedProperty(setup.ConnectionString, "LastUpdate");
				SqlServers.DeleteExtendedProperty(setup.ConnectionString, "ModelKey");
				SqlServers.DeleteExtendedProperty(setup.ConnectionString, "History");

				timer.Stop();
				LogInfo("Installation Complete, Model: " + MODELKEY + ", Elapsed time: " + timer.ElapsedMilliseconds);
			}
			catch (HandledSQLException ex)
			{
				//Do Nothing
			}
			catch (InvalidSQLException ex)
			{
				var F = new SqlErrorForm();
				F.Setup(ex, false);
				F.ShowDialog();
				if (_transaction == null)
					_transaction.Rollback();
				throw ex;
			}
			catch (Exception ex)
			{
				var F = new SqlErrorForm();
				F.SetupGeneric(ex);
				F.ShowDialog();
				//System.Windows.Forms.MessageBox.Show(ex.Message, "Error!", System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Error);
				if (_transaction == null)
					_transaction.Rollback();
				throw;
			}
			finally
			{
				_connection.Close();
			}

		}

		private void AppendCleanScript(string key, string script, StringBuilder sb)
		{
			if (string.IsNullOrEmpty(script)) return;
			var current = _databaseItems.FirstOrDefault(x => x.name.ToLower() == key.ToLower());

			var tempdb = new StringBuilder();
			var lines = script.Split(new string[] { "\r\n", "\n" }, StringSplitOptions.None);
			foreach (var s in lines)
			{
				if (!s.StartsWith("--MODELID"))
					tempdb.AppendLine(s);
			}
			tempdb.AppendLine("GO");
			sb.Append(tempdb.ToString());

			var hashValue = tempdb.ToString().CalculateMD5Hash();
			if (current != null)
			{
				if (current.Hash == hashValue)
				{
					//Skip
				}
				else
				{
					current.ModifiedDate = DateTime.Now;
					current.Hash = hashValue;
					current.Status = "applied";
				}
			}
			else
			{
				current = new nHydrateDbObject()
				{
					name = key,
					Hash = hashValue,
					ModelKey = new Guid(UpgradeInstaller.MODELKEY),
					type = "FILE",
					Status = "applied",
					Changed = true,
				};
				_databaseItems.Add(current);
			}
		}

		private void UpgradeFolder1(InstallSetup setup)
		{
			UpgradeFolder1(null, setup);
		}

		private void UpgradeFolder1(StringBuilder sb, InstallSetup setup)
		{
			const string MAIN_FOLDER = "._1_UserDefinedInitialization.";
			const string ALWAYS_FOLDER = MAIN_FOLDER + "Always";
			const string NEWDATABASE_FOLDER = MAIN_FOLDER + "NewDatabase";
			const string UNVERSIONED_FOLDER = MAIN_FOLDER + "UnVersioned";
			const string VERSIONED_FOLDER = MAIN_FOLDER + "Versioned";

			if (_setup.NewInstall) //NEW DATABASE
			{
				var scripts = this.GetResourceNameUnderLocation(NEWDATABASE_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, _databaseItems, setup);
					else SqlServers.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
				}
			}
			else if (_def_Version.Equals(_previousVersion)) //UNVERSIONED
			{
				var scripts = this.GetResourceNameUnderLocation(UNVERSIONED_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, _databaseItems, setup);
					else SqlServers.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
				}
			}
			else //VERSIONED
			{
				var scripts = this.GetResourceNameUnderLocation(VERSIONED_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, _databaseItems, setup);
					else SqlServers.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
				}
			}

			//RUN ALWAYS
			{
				var scripts = this.GetResourceNameUnderLocation(ALWAYS_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, _databaseItems, setup);
					else SqlServers.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
				}
			}

		}

		private void UpgradeFolder2(InstallSetup setup)
		{
			UpgradeFolder2(null, setup);
		}

		private void UpgradeFolder2(StringBuilder sb, InstallSetup setup)
		{
			if (setup.NewInstall) return;
			if (_previousVersion == _def_Version) return; //existing db with no version table

			var upgradeSchemaScripts = this.GetResourceNameUnderLocation(UPGRADE_GENERATED_FOLDER);
			var sortByVersionScripts = new SortedDictionary<string, EmbeddedResourceName>(upgradeSchemaScripts, new UpgradeFileNameComparer());

			//Run the generated upgrades
			foreach (EmbeddedResourceName ern in sortByVersionScripts.Values)
			{
				if (new GeneratedVersion(ern.FileName).CompareTo(_previousVersion) > 0)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, null, _databaseItems, setup);
					else SqlServers.ReadSQLFileSectionsFromResource(ern.FullName, setup).ToList().ForEach(s => AppendCleanScript(ern.FullName, s, sb));
				}
			}
		}

		private void UpgradeFolder3(InstallSetup setup)
		{
			UpgradeFolder3(null, setup);
		}

		private void UpgradeFolder3(StringBuilder sb, InstallSetup setup)
		{
			const string MAIN_FOLDER = "._3_GeneratedTablesAndData.";
			const string CREATE_SCHEMA_FILE = MAIN_FOLDER + "CreateSchema.sql";
			const string TRIGGER_FILE = MAIN_FOLDER + "CreateSchemaAuditTriggers.sql";
			const string STATIC_DATA_FILE = MAIN_FOLDER + "CreateData.sql";

			//Do not run installation scripts if versions match
			//if (_previousVersion.Equals(_upgradeToVersion))
			//	return;

			if (!setup.Normalize && setup.IsUpgrade) return;

			try
			{
				//Run the create schema
				var scripts = this.GetResourceNameUnderLocation(CREATE_SCHEMA_FILE);
				foreach (EmbeddedResourceName ern in scripts.Values)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, null, _databaseItems, setup);
					else SqlServers.ReadSQLFileSectionsFromResource(ern.FullName, setup).ToList().ForEach(s => AppendCleanScript(ern.FullName, s, sb));
				}

				//Run the static data
				scripts = this.GetResourceNameUnderLocation(STATIC_DATA_FILE);
				foreach (var ern in scripts.Values)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, null, _databaseItems, setup);
					else SqlServers.ReadSQLFileSectionsFromResource(ern.FullName, setup).ToList().ForEach(s => AppendCleanScript(ern.FullName, s, sb));
				}

				//Other static data
				scripts = this.GetResourceNameUnderLocation(MAIN_FOLDER);
				this.GetResourceNameUnderLocation(CREATE_SCHEMA_FILE).ToList().ForEach(x => scripts.Remove(x.Key));
				this.GetResourceNameUnderLocation(STATIC_DATA_FILE).ToList().ForEach(x => scripts.Remove(x.Key));
				this.GetResourceNameUnderLocation(TRIGGER_FILE).ToList().ForEach(x => scripts.Remove(x.Key));
				foreach (var ern in scripts.Values)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, null, _databaseItems, setup);
					else SqlServers.ReadSQLFileSectionsFromResource(ern.FullName, setup).ToList().ForEach(s => AppendCleanScript(ern.FullName, s, sb));
				}

				//Run the triggers
				scripts = this.GetResourceNameUnderLocation(TRIGGER_FILE);
				foreach (var ern in scripts.Values)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, null, _databaseItems, setup);
					else SqlServers.ReadSQLFileSectionsFromResource(ern.FullName, setup).ToList().ForEach(s => AppendCleanScript(ern.FullName, s, sb));
				}
			}
			catch (Exception ex)
			{
				throw;
			}
		}

		private void UpgradeFolder4(InstallSetup setup)
		{
			UpgradeFolder4(null, setup);
		}

		private void UpgradeFolder4(StringBuilder sb, InstallSetup setup)
		{
			const string MAIN_FOLDER = "._4_UserDefinedPostTablesAndData.";
			const string ALWAYS_FOLDER = MAIN_FOLDER + "Always";
			const string NEWDATABASE_FOLDER = MAIN_FOLDER + "NewDatabase";
			const string UNVERSIONED_FOLDER = MAIN_FOLDER + "UnVersioned";
			const string VERSIONED_FOLDER = MAIN_FOLDER + "Versioned";

			if (_setup.NewInstall) //NEW DATABASE
			{
				var scripts = this.GetResourceNameUnderLocation(NEWDATABASE_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, _databaseItems, setup);
					else SqlServers.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
				}
			}
			else if (_def_Version.Equals(_previousVersion)) //UNVERSIONED
			{
				var scripts = this.GetResourceNameUnderLocation(UNVERSIONED_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, _databaseItems, setup);
					else SqlServers.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
				}
			}
			else //VERSIONED
			{
				var scripts = this.GetResourceNameUnderLocation(VERSIONED_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, _databaseItems, setup);
					else SqlServers.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
				}
			}

			//RUN ALWAYS
			{
				var scripts = this.GetResourceNameUnderLocation(ALWAYS_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, _databaseItems, setup);
					else SqlServers.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
				}
			}

		}

		private void UpgradeFolder5(InstallSetup setup)
		{
			UpgradeFolder5(null, setup);
		}

		/// <summary>
		/// Run Model/User-Defined Scripts from Programmability
		/// </summary>
		private void UpgradeFolder5(StringBuilder sb, InstallSetup setup)
		{
			const string MAIN_FOLDER = "._5_Programmability.";

			//Run user-defined objects and get determine an order for them if necessary (on failure)
			var failedScripts = new List<KeyValuePair<Guid, string>>();
			var successOrderScripts = new List<Guid>();

			//User-defined (Manually Added)
			var alluserDefinedScripts = GetUserDefinedScripts(MAIN_FOLDER + "Stored_Procedures.User_Defined", setup);
			alluserDefinedScripts = alluserDefinedScripts.Concat(GetUserDefinedScripts(MAIN_FOLDER + "Views.User_Defined", setup)).ToDictionary(x => x.Key, x => x.Value);
			alluserDefinedScripts = alluserDefinedScripts.Concat(GetUserDefinedScripts(MAIN_FOLDER + "Functions.User_Defined", setup)).ToDictionary(x => x.Key, x => x.Value);

			//If Create or upgrade with normalize then install model objects
			if (setup.Normalize || setup.UseHashes || !setup.IsUpgrade)
			{
				//Model (managed)
				alluserDefinedScripts = alluserDefinedScripts.Concat(ParseInternalScripts(GetUserDefinedScripts(MAIN_FOLDER + "Stored_Procedures.Model", setup))).ToDictionary(x => x.Key, x => x.Value);
				alluserDefinedScripts = alluserDefinedScripts.Concat(ParseInternalScripts(GetUserDefinedScripts(MAIN_FOLDER + "Views.Model", setup))).ToDictionary(x => x.Key, x => x.Value);
				alluserDefinedScripts = alluserDefinedScripts.Concat(ParseInternalScripts(GetUserDefinedScripts(MAIN_FOLDER + "Functions.Model", setup))).ToDictionary(x => x.Key, x => x.Value);
			}

			if (sb == null)
			{
				this.ReinstallUserDefinedScripts(this.ReorderScripts(alluserDefinedScripts), failedScripts, successOrderScripts, _databaseItems, setup);
				this.RunErrors(failedScripts, successOrderScripts, setup);
			}
			else
			{
				var list = this.ReorderScripts(alluserDefinedScripts);
				list.Keys.ToList().ForEach(key => AppendCleanScript(key, string.Join("\r\nGO\r\n", list[key]), sb));
			}

			//Run internal objects last. They should always work
			this.ReinstallStoredProceduresInternal(null, sb, setup);
		}

		private void UpgradeFolder6(InstallSetup setup)
		{
			UpgradeFolder6(null, setup);
		}

		private void UpgradeFolder6(StringBuilder sb, InstallSetup setup)
		{
			const string MAIN_FOLDER = "._6_UserDefinedFinalize.";
			const string ALWAYS_FOLDER = MAIN_FOLDER + "Always";
			const string NEWDATABASE_FOLDER = MAIN_FOLDER + "NewDatabase";
			const string UNVERSIONED_FOLDER = MAIN_FOLDER + "UnVersioned";
			const string VERSIONED_FOLDER = MAIN_FOLDER + "Versioned";

			if (_setup.NewInstall) //NEW DATABASE
			{
				var scripts = this.GetResourceNameUnderLocation(NEWDATABASE_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, null, _databaseItems, setup);
					else SqlServers.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
				}
			}
			else if (_def_Version.Equals(_previousVersion)) //UNVERSIONED
			{
				var scripts = this.GetResourceNameUnderLocation(UNVERSIONED_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, null, _databaseItems, setup);
					else SqlServers.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
				}
			}
			else //VERSIONED
			{
				var scripts = this.GetResourceNameUnderLocation(VERSIONED_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, null, _databaseItems, setup);
					else SqlServers.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
				}
			}

			//RUN ALWAYS
			{
				var scripts = this.GetResourceNameUnderLocation(ALWAYS_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, null, _databaseItems, setup);
					else SqlServers.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
				}
			}

		}

		private Dictionary<string, List<string>> ParseInternalScripts(Dictionary<string, List<string>> list)
		{
			var retval = new Dictionary<string, List<string>>();
			var indexList = new Dictionary<string, int>(); //keeps track of the index when GUID are duplicate
			foreach (var key in list.Keys)
			{
				var sqlList = list[key];
				foreach (var sql in sqlList)
				{
					var lines = sql.Split('\n');
					var line = lines.FirstOrDefault(x => x.Contains("--MODELID,BODY:"));
					if (string.IsNullOrEmpty(line))
						line = lines.FirstOrDefault(x => x.Contains("--MODELID:"));

					var itemId = key + "-" + key.CalculateMD5Hash().ToLower();
					if (!string.IsNullOrEmpty(line))
					{
						try
						{
							line = line.Replace("--MODELID,BODY:", string.Empty).Replace("--MODELID:", string.Empty).Trim();
							if (line.Length == 36) //Use the Model ID Guid
								itemId = key + "-" + line.ToLower();
						}
						catch (Exception ex)
						{
							//Do Nothing
						}
					}

					var currentIndex = 1;
					if (indexList.ContainsKey(itemId))
						currentIndex = ++indexList[itemId];
					else
						indexList.Add(itemId, currentIndex);

					retval.Add(itemId + "-" + currentIndex, new List<string>(new[] { sql }));
				}
			}
			return retval;
		}


		private void RunErrors(List<KeyValuePair<Guid, string>> failedScripts, InstallSetup setup)
		{
			RunErrors(failedScripts, null, setup);
		}

		private void RunErrors(List<KeyValuePair<Guid, string>> failedScripts, List<Guid> successOrderScripts, InstallSetup setup)
		{
			if (failedScripts.Count == 0) return;
			var runFailed = true;
			do
			{
				var _scripts2 = new List<KeyValuePair<Guid, string>>();
				foreach (var item in failedScripts)
				{
					var key = item.Key;
					var sql = item.Value;
					SqlServers.ExecuteSQL(_connection, _transaction, sql, setup, _scripts2, successOrderScripts);
				}
				runFailed = (_scripts2.Count < failedScripts.Count && _scripts2.Count > 0);
				failedScripts = _scripts2;
			} while (runFailed);

			if (failedScripts.Count > 0)
			{
				//This will throw a proper error
				SqlServers.ExecuteSQL(_connection, _transaction, failedScripts.First().Value, setup);
				//Use this for debugging if necessary
				var sql = string.Join("\r\n\r\nGO\r\n--SCRIPT BREAK\r\n\r\n", failedScripts.Select(x => x.Value));
			}
			else if (successOrderScripts != null)
			{
				//Only do this in debug
#if (DEBUG)
				if (System.Diagnostics.Debugger.IsAttached)
				{
					var nOrderFile = System.IO.Path.Combine(new System.IO.FileInfo(System.Reflection.Assembly.GetExecutingAssembly().Location).DirectoryName, "installer.norder");
					//If there are no failures then ensure that there is no "norder" file
					if (System.IO.File.Exists(nOrderFile))
						System.IO.File.Delete(nOrderFile);

					//On success, write the XML file with the proper order
					try
					{
						var document = new System.Xml.XmlDocument();
						document.LoadXml("<root type=\"installer\"></root>");
						document.DocumentElement.AppendChild(document.CreateWhitespace("\r\n"));
						foreach (var k in successOrderScripts)
						{
							document.DocumentElement.AddElement("key", k.ToString());
							document.DocumentElement.AppendChild(document.CreateWhitespace("\r\n"));
						}
						document.Save(nOrderFile);
					}
					catch (Exception ex)
					{
					}
				}
#endif
			}
		}

		#region Get Internal Objects

		private void ReinstallStoredProceduresInternal(List<KeyValuePair<Guid, string>> failedScripts, StringBuilder sb, InstallSetup setup)
		{
			try
			{
				var storedProcedures = this.GetResourceNameUnderLocation("._5_Programmability.Stored_Procedures.Internal");
				foreach (EmbeddedResourceName ern in storedProcedures.Values)
				{
					try
					{
						if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, failedScripts, _databaseItems, setup);
						else SqlServers.ReadSQLFileSectionsFromResource(ern.FullName, setup).ToList().ForEach(s => AppendCleanScript(ern.FullName, s, sb));
					}
					catch
					{
						System.Windows.Forms.MessageBox.Show("Sp Fail: " + ern.FullName);
						throw;
					}
				}
			}
			catch
			{
				throw;
			}
		}

		#endregion

		#region Get User-Defined Objects

		private Dictionary<string, List<string>> GetUserDefinedScripts(string subFolder, InstallSetup setup)
		{
			try
			{
				var retval = new Dictionary<string, List<string>>();
				var storedProcedures = this.GetResourceNameUnderLocation(subFolder);
				foreach (var ern in storedProcedures.Values)
				{
					try
					{
						//Skip Internal
						if (!ern.FullName.Contains(subFolder + ".Internal"))
						{
							var current = _databaseItems.FirstOrDefault(x => x.name.ToLower() == ern.FullName.ToLower());
							var scripts = SqlServers.GetEmbeddedScripts(ern.FullName, setup);

							#region Strip internal stuff for hashing
							var script = string.Join("\r\nGO\r\n", scripts);
							var tempdb = new StringBuilder();
							var lines = script.Split(new string[] { "\r\n", "\n" }, StringSplitOptions.None);
							foreach (var s in lines)
							{
								if (!s.StartsWith("--MODELID"))
									tempdb.AppendLine(s);
							}
							tempdb.AppendLine("GO");
							#endregion

							var hashValue = tempdb.ToString().CalculateMD5Hash();
							if (current != null && current.Hash == hashValue && setup.UseHashes)
							{
								//Skip item
							}
							else
							{
								if (current == null)
								{
									current = new nHydrateDbObject()
									{
										name = ern.FullName,
										Hash = hashValue,
										ModelKey = new Guid(UpgradeInstaller.MODELKEY),
										type = "FILE",
									};
								}
								else
								{
									current.Changed = true;
									current.Hash = hashValue;
								}

								retval.Add(ern.FullName, scripts);
							}
						}
					}
					catch
					{
						System.Windows.Forms.MessageBox.Show("Sp Fail: " + ern.FullName);
						throw;
					}
				}
				return retval;
			}
			catch
			{
				throw;
			}
		}

		private Dictionary<string, List<string>> ReorderScripts(Dictionary<string, List<string>> allScripts)
		{
			var l = this.GetResourceNameUnderLocation("._5_Programmability.ScriptOrder.nOrder");

			//Make a copy fo the input list
			var inputCopy = new Dictionary<string, List<string>>();
			allScripts.Keys.ToList().ForEach(x => inputCopy.Add(x, allScripts[x]));

			var reorderedScripts = new Dictionary<string, List<string>>();
			if (l.Values.Count > 0)
			{
				var xml = SqlServers.GetEmbeddedResource(l.Values.First().FullName);
				var document = new XmlDocument();
				try
				{
					//Load the ordered key list
					document.LoadXml(xml);

					//Loop through ordered key list and put scripts in order
					foreach (XmlNode n in document.DocumentElement.ChildNodes)
					{
						//Find a script with the specified key
						var scriptMatch = allScripts.Where(x => string.Join(string.Empty, x.Value).ToLower().Contains(n.InnerText.ToLower())).ToList();
						foreach (var script in scriptMatch)
						{
							//if the script is found move it to the top of the list
							reorderedScripts.Add(script.Key, script.Value);

							//remove this item from the unordered list
							inputCopy.Remove(script.Key);
						}
					}

					//Now that we have ordered the scripts and removed the originals now prepend the ordered list to the top of the scripts list
					inputCopy.Keys.ToList().ForEach(x => reorderedScripts.Add(x, inputCopy[x]));
				}
				catch (Exception ex)
				{
					//Do Nothing
				}
			}
			else
			{
				reorderedScripts = inputCopy;
			}

			return reorderedScripts;
		}

		private void ReinstallUserDefinedScripts(Dictionary<string, List<string>> allScripts, List<KeyValuePair<Guid, string>> failedScripts, List<Guid> successOrderScripts, List<nHydrateDbObject> _databaseItems, InstallSetup setup)
		{
			//Run all the scripts
			var newHashList = new Dictionary<nHydrateDbObject, string>();
			foreach (var key in allScripts.Keys)
			{
				var scriptItem = allScripts[key];

				#region Load script hashes

				var runScript = false;
				var current = _databaseItems.FirstOrDefault(x => x.name.ToLower() == key.ToLower());
				var groupScripts = allScripts.Where(x => x.Key == key).ToList();
				var v = string.Join("\r\nGO\r\n", groupScripts.SelectMany(x => x.Value).Select(x => x).ToList());
				var hashValue = v.CalculateMD5Hash();

				if (current != null)
				{
					if (current.Hash != hashValue)
					{
						runScript = true;
						current.ModifiedDate = DateTime.Now;
					}

					if (!newHashList.ContainsKey(current))
						newHashList.Add(current, hashValue);
				}
				else
				{
					runScript = true;
					current = new nHydrateDbObject()
					{
						name = key,
						Hash = hashValue,
						ModelKey = new Guid(UpgradeInstaller.MODELKEY),
						type = "FILE",
						Changed = true,
					};
				}

				//Add this item to list if it is new
				if (!_databaseItems.Any(x => x.name.ToLower() == key.ToLower()))
					_databaseItems.Add(current);

				#endregion

				if ((runScript && setup.UseHashes) || !setup.UseHashes)
				{
					foreach (var sql in scriptItem)
					{
						SqlServers.ExecuteSQL(_connection, _transaction, sql, setup, failedScripts, successOrderScripts);
					}
				}

			}

			foreach (var k in newHashList.Keys)
				_databaseItems.FirstOrDefault(x => x == k).Hash = newHashList[k];

		}

		private void ReinstallStoredProceduresUserDefined(List<KeyValuePair<Guid, string>> failedScripts, List<Guid> successOrderScripts, InstallSetup setup)
		{
			try
			{
				var storedProcedures = this.GetResourceNameUnderLocation(".Stored_Procedures");
				foreach (EmbeddedResourceName ern in storedProcedures.Values)
				{
					try
					{
						//Skip Internal
						if (!ern.FullName.Contains(".Stored_Procedures.Internal"))
							SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, failedScripts, successOrderScripts, _databaseItems, setup);
					}
					catch
					{
						System.Windows.Forms.MessageBox.Show("Sp Fail: " + ern.FullName);
						throw;
					}
				}
			}
			catch
			{
				throw;
			}
		}

		private void ReinstallFunctionsUserDefined(List<KeyValuePair<Guid, string>> failedScripts, List<Guid> successOrderScripts, InstallSetup setup)
		{
			try
			{
				var storedProcedures = this.GetResourceNameUnderLocation(".Functions");
				foreach (EmbeddedResourceName ern in storedProcedures.Values)
				{
					try
					{
						//Skip Internal
						if (!ern.FullName.Contains(".Functions.Internal"))
							SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, failedScripts, successOrderScripts, _databaseItems, setup);
					}
					catch
					{
						System.Windows.Forms.MessageBox.Show("Function Fail: " + ern.FullName);
						throw;
					}
				}
			}
			catch
			{
				throw;
			}
		}

		private void ReinstallViewsUserDefined(List<KeyValuePair<Guid, string>> failedScripts, List<Guid> successOrderScripts, InstallSetup setup)
		{
			try
			{
				var storedProcedures = this.GetResourceNameUnderLocation(".Views");
				foreach (EmbeddedResourceName ern in storedProcedures.Values)
				{
					try
					{
						//Skip Internal
						if (!ern.FullName.Contains(".Views.Internal"))
							SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, failedScripts, successOrderScripts, _databaseItems, setup);
					}
					catch
					{
						System.Windows.Forms.MessageBox.Show("Sp Fail: " + ern.FullName);
						throw;
					}
				}
			}
			catch
			{
				throw;
			}
		}

		#endregion

		private SortedDictionary<string, EmbeddedResourceName> GetResourceNameUnderLocation(string location)
		{
			var excludePathList = new List<string>();
			return GetResourceNameUnderLocation(location, excludePathList);
		}

		private SortedDictionary<string, EmbeddedResourceName> GetResourceNameUnderLocation(string location, List<string> excludePathList)
		{
			try
			{
				var retVal = new SortedDictionary<string, EmbeddedResourceName>();
				foreach (EmbeddedResourceName ern in _resourceNames.OrderBy(x => x.FullName))
				{
					if (ern.AsmLocation.StartsWith(location))
					{
						bool exclude = false;
						foreach (string path in excludePathList)
						{
							if (ern.AsmLocation.StartsWith(path))
								exclude = true;
						}

						if (!exclude) retVal.Add(ern.FullName, ern);
					}
				}
				return retVal;
			}
			catch
			{
				throw;
			}

		}

		private SortedDictionary<string, EmbeddedResourceName> GetResourceFileNameContains(string fileNamePart)
		{
			var retVal = new SortedDictionary<string, EmbeddedResourceName>();
			foreach (EmbeddedResourceName ern in _resourceNames.OrderBy(x => x.FullName))
			{
				if (ern.FileName.Contains(fileNamePart))
				{
					retVal.Add(ern.FileName, ern);
				}
			}
			return retVal;
		}

		#region UpgradeFileNameComparer class

		private class UpgradeFileNameComparer : IComparer<string>
		{
			#region IComparer<string> Members

			public int Compare(string x, string y)
			{
				return new GeneratedVersion(x).CompareTo(new GeneratedVersion(y));
			}

			#endregion
		}

		#endregion

		#region EmbeddedResourceName class

		private class EmbeddedResourceName
		{
			#region Members

			private string _fullName;
			private string _fileName;
			private string _fileExtension;
			private string _asmLocation;
			private string _asmNamespace;

			#endregion

			#region Constructors

			public EmbeddedResourceName(string fullName)
			{
				string[] splitName = fullName.Split('.');
				_fullName = fullName;
				_fileName = splitName[splitName.Length - 2];
				_fileExtension = splitName[splitName.Length - 1];
				_asmNamespace = DEFAULT_NAMESPACE;
				int namespaceCount = DEFAULT_NAMESPACE.Split('.').Length;
				_asmLocation = string.Empty;
				for (var ii = namespaceCount; ii < splitName.Length; ii++)
				{
					_asmLocation += "." + splitName[ii];
				}
				_asmLocation.Trim(new char[] { '.' });
			}

			#endregion

			#region Properties

			public string FullName
			{
				get { return _fullName; }
			}

			public string FileName
			{
				get { return _fileName; }
			}

			public string FileExtension
			{
				get { return _fileExtension; }
			}

			public string AsmLocation
			{
				get { return _asmLocation; }
			}

			public string AsmNamespace
			{
				get { return _asmNamespace; }
			}

			#endregion
		}

		#endregion

		public static void LogInfo(string text)
		{
			try
			{
				var fileName = Path.Combine(Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location),
																		Path.GetFileNameWithoutExtension(System.Reflection.Assembly.GetExecutingAssembly().Location) + ".log");

				if (!string.IsNullOrEmpty(text))
					File.AppendAllText(fileName, "[" + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + "] " + text + "\r\n");
			}
			catch
			{
				//Do Nothing
			}
		}

		public static void LogError(Exception exception, string otherText)
		{
			try
			{
				var fileName = Path.Combine(Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location),
																		Path.GetFileNameWithoutExtension(System.Reflection.Assembly.GetExecutingAssembly().Location) + ".errorlog.txt");

				var text = string.Empty;

				if (exception != null)
					text += exception.ToString() + "\r\n\r\n";

				if (!string.IsNullOrEmpty(otherText))
					text += otherText + "\r\n\r\n";

				if (!string.IsNullOrEmpty(text))
					File.AppendAllText(fileName, "[" + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + "]\r\n" + text);
			}
			catch
			{
				//Do Nothing
			}
		}

	}

	#region Version Class

	/// <summary />
	public class GeneratedVersion : IComparable<GeneratedVersion>
	{
		#region member variables
		private int _major = 0;
		private int _minor = 0;
		private int _revision = 0;
		private int _build = 0;
		private int _generated = 0;
		#endregion

		#region Constructors

		internal GeneratedVersion()
		{
		}

		internal GeneratedVersion(int major, int minor, int revision, int build)
			: this()
		{
			_major = major;
			_minor = minor;
			_revision = revision;
			_build = build;
		}

		/// <summary />
		public GeneratedVersion(int major, int minor, int revision, int build, int generated)
			: this(major, minor, revision, build)
		{
			_generated = generated;
		}

		internal GeneratedVersion(GeneratedVersion version)
		{
			_build = version._build;
			_generated = version._generated;
			_major = version._major;
			_minor = version._minor;
			_revision = version._revision;
		}

		internal GeneratedVersion(string[] versionSplit)
			: this()
		{
			if (versionSplit.Length > 0) int.TryParse(versionSplit[0], out _major);
			if (versionSplit.Length > 1) int.TryParse(versionSplit[1], out _minor);
			if (versionSplit.Length > 2) int.TryParse(versionSplit[2], out _revision);
			if (versionSplit.Length > 3) int.TryParse(versionSplit[3], out _build);
			if (versionSplit.Length > 4) int.TryParse(versionSplit[4], out _generated);
		}

		/// <summary>
		/// Determines if the specified string can be parsed as a version
		/// </summary>
		public static bool IsValid(string v)
		{
			if (string.IsNullOrEmpty(v))
				return false;

			var arr1 = v.Split('.');
			if (arr1.Length == 5)
			{
				foreach (var q in arr1)
				{
					int o;
					if (!int.TryParse(q, out o))
						return false;
				}
				return true;
			}
			return false;
		}

		internal GeneratedVersion(string fileName)
		{
			try
			{
				if (fileName.Contains("_"))
				{
					var arr1 = fileName.Split('.');
					if (arr1.Length >= 1)
					{
						string[] versionSplit = null;

						if (arr1.Length == 1)
							versionSplit = arr1[0].Split('_');
						else
							versionSplit = arr1[arr1.Length - 2].Split('_');

						if (versionSplit.Length >= 5)
						{
							if (versionSplit.Length > 0) int.TryParse(versionSplit[0], out _major);
							if (versionSplit.Length > 1) int.TryParse(versionSplit[1], out _minor);
							if (versionSplit.Length > 2) int.TryParse(versionSplit[2], out _revision);
							if (versionSplit.Length > 3) int.TryParse(versionSplit[3], out _build);
							if (versionSplit.Length > 4) int.TryParse(versionSplit[4], out _generated);
							return;
						}
					}
					_major = -45;
				}
				else
				{
					var arr1 = fileName.Split('.');
					if (arr1.Length >= 5)
					{
						if (arr1.Length > 0) int.TryParse(arr1[0], out _major);
						if (arr1.Length > 1) int.TryParse(arr1[1], out _minor);
						if (arr1.Length > 2) int.TryParse(arr1[2], out _revision);
						if (arr1.Length > 3) int.TryParse(arr1[3], out _build);
						if (arr1.Length > 4) int.TryParse(arr1[4], out _generated);
					}
				}
			}
			catch
			{
			}
		}

		#endregion

		#region Properties

		/// <summary />
		public int Major
		{
			get { return _major; }
			set { _major = value; }
		}

		/// <summary />
		public int Minor
		{
			get { return _minor; }
			set { _minor = value; }
		}

		/// <summary />
		public int Revision
		{
			get { return _revision; }
			set { _revision = value; }
		}

		/// <summary />
		public int Build
		{
			get { return _build; }
			set { _build = value; }
		}

		/// <summary />
		public int Generated
		{
			get { return _generated; }
			set { _generated = value; }
		}

		#endregion

		#region IComparable<Version> Members

		/// <summary />
		public int CompareTo(GeneratedVersion other)
		{
			if (this.Major != other.Major)
				return this.Major.CompareTo(other.Major);
			else if (this.Minor != other.Minor)
				return this.Minor.CompareTo(other.Minor);
			else if (this.Revision != other.Revision)
				return this.Revision.CompareTo(other.Revision);
			else if (this.Build != other.Build)
				return this.Build.CompareTo(other.Build);
			else if (this.Generated != other.Generated)
				return this.Generated.CompareTo(other.Generated);
			else
				return 0;
		}

		#endregion

		#region Methods

		/// <summary />
		public override bool Equals(object obj)
		{
			if (!(obj is GeneratedVersion)) return false;
			var v = (GeneratedVersion)obj;
			return (v.Build == this.Build) &&
				(v.Generated == this.Generated) &&
				(v.Major == this.Major) &&
				(v.Minor == this.Minor) &&
				(v.Revision == this.Revision);
		}

		/// <summary />
		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		/// <summary />
		public string ToString(string seperationChars)
		{
			string retval = this.Major + seperationChars + this.Minor + seperationChars + this.Revision + seperationChars + this.Build;
			if (this.Generated != 0) retval += seperationChars + this.Generated;
			return retval;
		}

		/// <summary />
		public override string ToString()
		{
			return this.ToString(".");
		}

		#endregion

		#region Operators

		/// <summary />
		public static bool operator <(GeneratedVersion r1, GeneratedVersion r2)
		{
			if ((object)r1 == null && (object)r2 == null) return false;
			if ((object)r1 == null ^ (object)r2 == null) return false;

			if (r1.Major < r2.Major) return true;
			if (r1.Major > r2.Major) return false;

			if (r1.Minor < r2.Minor) return true;
			if (r1.Minor > r2.Minor) return false;

			if (r1.Revision < r2.Revision) return true;
			if (r1.Revision > r2.Revision) return false;

			if (r1.Build < r2.Build) return true;
			if (r1.Build > r2.Build) return false;

			if (r1.Generated < r2.Generated) return true;
			if (r1.Generated > r2.Generated) return false;

			return false;
		}

		/// <summary />
		public static bool operator >(GeneratedVersion r1, GeneratedVersion r2)
		{
			if ((object)r1 == null && (object)r2 == null) return false;
			if ((object)r1 == null ^ (object)r2 == null) return false;

			if (r1.Major > r2.Major) return true;
			if (r1.Major < r2.Major) return false;

			if (r1.Minor > r2.Minor) return true;
			if (r1.Minor < r2.Minor) return false;

			if (r1.Revision > r2.Revision) return true;
			if (r1.Revision < r2.Revision) return false;

			if (r1.Build > r2.Build) return true;
			if (r1.Build < r2.Build) return false;

			if (r1.Generated > r2.Generated) return true;
			if (r1.Generated < r2.Generated) return false;

			return false;
		}

		/// <summary />
		public static bool operator ==(GeneratedVersion r1, GeneratedVersion r2)
		{
			if ((object)r1 == null && (object)r2 == null) return true;
			if ((object)r1 == null ^ (object)r2 == null) return false;
			if (r1 < r2) return false;
			if (r1 > r2) return false;
			return true;
		}

		/// <summary />
		public static bool operator !=(GeneratedVersion r1, GeneratedVersion r2)
		{
			if ((object)r1 == null && (object)r2 == null) return false;
			if ((object)r1 == null ^ (object)r2 == null) return true;
			if (r1 < r2) return true;
			if (r1 > r2) return true;
			return false;
		}

		#endregion

	}
	#endregion

	#region EncryptionLibrary

	/// <summary />
	public partial class EncryptionLibrary
	{
		/// <summary>
		/// Override this method to implement your own hashing algorithm
		/// </summary>
		/// <param name="input">The input string to hash</param>
		/// <param name="output">Set this parameter to a string with 1 or more characters to override the default hashing algorithm</param>
		/// <returns></returns>
		partial void HashOverride(string input, ref string output);

		/// <summary />
		public string Hash(string input)
		{
			string output = string.Empty;
			HashOverride(input, ref output);
			if (!string.IsNullOrEmpty(output)) return output;
			return CalculateMD5(input);
		}

		private string CalculateMD5(string input)
		{
			// step 1, calculate MD5 hash from input
			var md5 = System.Security.Cryptography.MD5.Create();
			var inputBytes = System.Text.Encoding.ASCII.GetBytes(input);
			var hash = md5.ComputeHash(inputBytes);

			// step 2, convert byte array to hex string
			var sb = new StringBuilder();
			for (var i = 0; i < hash.Length; i++)
			{
				sb.Append(hash[i].ToString("X2"));
			}
			return sb.ToString();
		}
	}

	#endregion

	#region Extensions

	/// <summary />
	internal static class Extensions
	{
		/// <summary />
		public static string CalculateMD5Hash(this string input)
		{
			var q = new EncryptionLibrary();
			return q.Hash(input);
		}

		private static readonly string PHash = "Pa@Sw0rd96d$";
		private static readonly string SaltKey = "8s$w@r1%";
		private static readonly string VIKey = "@2C1c3D4e5F6g7H8";

		/// <summary />
		public static string Encrypt(this string plainText)
		{
			try
			{
				var plainTextBytes = Encoding.UTF8.GetBytes(plainText);
				var keyBytes = new Rfc2898DeriveBytes(PHash, Encoding.ASCII.GetBytes(SaltKey)).GetBytes(256 / 8);
				var symmetricKey = new RijndaelManaged() { Mode = CipherMode.CBC, Padding = PaddingMode.Zeros };
				var encryptor = symmetricKey.CreateEncryptor(keyBytes, Encoding.ASCII.GetBytes(VIKey));
				byte[] cipherTextBytes;
				using (var memoryStream = new MemoryStream())
				{
					using (var cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write))
					{
						cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);
						cryptoStream.FlushFinalBlock();
						cipherTextBytes = memoryStream.ToArray();
						cryptoStream.Close();
					}
					memoryStream.Close();
				}
				return Convert.ToBase64String(cipherTextBytes);
			}
			catch (Exception ex)
			{
				return null;
			}
		}

		/// <summary />
		public static string Decrypt(this string encryptedText)
		{
			try
			{
				var cipherTextBytes = Convert.FromBase64String(encryptedText);
				var keyBytes = new Rfc2898DeriveBytes(PHash, Encoding.ASCII.GetBytes(SaltKey)).GetBytes(256 / 8);
				var symmetricKey = new RijndaelManaged() { Mode = CipherMode.CBC, Padding = PaddingMode.None };
				var decryptor = symmetricKey.CreateDecryptor(keyBytes, Encoding.ASCII.GetBytes(VIKey));
				var memoryStream = new MemoryStream(cipherTextBytes);
				var cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read);
				var plainTextBytes = new byte[cipherTextBytes.Length];
				var decryptedByteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length);
				memoryStream.Close();
				cryptoStream.Close();
				return Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount).TrimEnd("\0".ToCharArray());
			}
			catch (Exception ex)
			{
				return null;
			}
		}

	}
	#endregion

}
#pragma warning restore 0168